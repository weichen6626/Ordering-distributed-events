#!/usr/bin/env python3
import sys
import struct
from threading import Lock, Thread
try:
    from queue import Queue
except ImportError:
    from Queue import Queue

import socket
import time


"""
    Global variables
"""
SELF_NODE = None
hostname = socket.gethostname()
SELF_IP = socket.gethostbyname(hostname)
SELF_PORT = 1234
SELF_PRIORITY = 0
CONNECTION_DICT = dict()
OTHER_NODE_LIST = []

TRANS_QUEUE = Queue()
ACCOUNT_DICT = {}

SEEN_MSGS_SET = set()
SEEN_QUEUE = Queue()
RECV_QUEUE = Queue()
ISIS_QUEUE = Queue()
ISIS_RESP_DICT = {}

BW_QUEUE = Queue()
MSG_TIME_DICT = {}

thread_lock = Lock()


def client_conn(s, addr):
    """
    Thread function for accept_conn to receive messages from a client.

    ...

    Parameters
    ----------
    s : socket object
        The new socket to receive data on the connection.
    addr : 
        The addres bound to the socket on the other end of the connection.
    """
    global RECV_QUEUE
    global MSG_TIME_DICT
    global BW_QUEUE

    while True:
        len = s.recv(4)
        if not len:
            break

        msglen = struct.unpack('>I', len)[0]
        time.sleep(0.00005)
        msg = s.recv(msglen)
        if not msg:
            break
        msg = msg.decode()
        key = ','.join(msg.split(',')[0:3])

        thread_lock.acquire()
        RECV_QUEUE.put(msg)
        MSG_TIME_DICT[key] = time.time()
        BW_QUEUE.put(sys.getsizeof(len))
        BW_QUEUE.put(sys.getsizeof(msg))
        thread_lock.release()

    s.close()
    thread_lock.acquire()
    CONNECTION_DICT.pop(addr)
    thread_lock.release()
    print(addr + " disconnected")


def accept_conn():
    """
    Thread function to accept connection from clients.

    """
    while True:
        try:
            conn, address = sock.accept()
            t = Thread(target=client_conn, args=(conn, address[0]))
            t.start()
        except:
            print("accept_conn error")


def connect_other():
    """
    Thread function to connect to all other nodes in the system.
    
    """
    global OTHER_NODE_LIST
    global CONNECTION_DICT
    while OTHER_NODE_LIST:
        (target, port) = OTHER_NODE_LIST[0]
        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            #print("Connecting to: " + target)
            conn.connect((target, port))
            thread_lock.acquire()
            CONNECTION_DICT[target] = conn
            thread_lock.release()
            OTHER_NODE_LIST = [x for x in OTHER_NODE_LIST if x[0] != target]
        except:
            time.sleep(1.0)


def transactions():
    """
    Thread function to handle transactions and print balances.
    
    """
    global TRANS_QUEUE
    global ACCOUNT_DICT

    while True:
        thread_lock.acquire()
        if TRANS_QUEUE.empty():
            thread_lock.release()
            time.sleep(0.0001)
            continue

        trans = TRANS_QUEUE.get().split()
        thread_lock.release()

        if trans[0] == "DEPOSIT":
            if trans[1] not in ACCOUNT_DICT:
                ACCOUNT_DICT[trans[1]] = 0
            ACCOUNT_DICT[trans[1]] += int(trans[2])

            bal_str = "BALANCES "
            for act, fund in sorted(ACCOUNT_DICT.items()):
                if fund != 0:
                    bal_str += "%s:%d " % (act, fund)
            print(bal_str)

        elif trans[0] == "TRANSFER":
            if trans[1] not in ACCOUNT_DICT:
                continue
            if ACCOUNT_DICT[trans[1]] < int(trans[4]):
                continue
            if trans[3] not in ACCOUNT_DICT:
                ACCOUNT_DICT[trans[3]] = 0

            ACCOUNT_DICT[trans[1]] -= int(trans[4])
            ACCOUNT_DICT[trans[3]] += int(trans[4])

            bal_str = "BALANCES "
            for act, fund in sorted(ACCOUNT_DICT.items()):
                if fund != 0:
                    bal_str += "%s:%d " % (act, fund)
            print(bal_str)

        else:
            print("invalid transaction: ", trans[0])


def read_stdin():
    """
    Thread function to read transactions from stdin generated by gentx.py.

    """
    global RECV_QUEUE
    global SELF_IP
    global SELF_PRIORITY

    for line in sys.stdin:

        thread_lock.acquire()
        line += ",%s,%s,%s,%s" % (SELF_IP, SELF_PRIORITY,
                                  SELF_IP, SELF_PRIORITY)
        SELF_PRIORITY += 1
        if len(line) < 40:
            print("read_stdin: ", line)
        RECV_QUEUE.put(line)
        thread_lock.release()
        r_multicast(line)


def isis_send():
    """
    Thread function for Isis algorithm to store the TRANS_QUEUE.

    """
    global ISIS_RESP_DICT
    global TRANS_QUEUE

    while True:
        least = (99999.0, 0, False)
        thread_lock.acquire()
        for k, val in ISIS_RESP_DICT.items():
            if val < least:
                least = val
                key = k

        if least[2] == True:
            key_fields = key.split(',')
            TRANS_QUEUE.put(key_fields[0])
            MSG_TIME_DICT[key] = time.time() - MSG_TIME_DICT[key]

            del ISIS_RESP_DICT[key]

        thread_lock.release()
        time.sleep(0.0001)


def clear_seen_msg():
    """
    Thread function to clean up the SEEN_QUEUE buffer.

    """
    global SEEN_MSGS_SET
    global SEEN_QUEUE
    while True:
        thread_lock.acquire()
        if SEEN_QUEUE.qsize() > 50000:
            SEEN_MSGS_SET.remove(SEEN_QUEUE.get())
        thread_lock.release()
        time.sleep(0.001)


def isis_recv():
    """
    Thread function for the Isis algo to process the received messages.
        
    """
    global ISIS_RESP_DICT
    global ISIS_QUEUE
    global SEEN_MSGS_SET
    global SELF_PRIORITY
    global SELF_IP
    global CONNECTION_DICT

    while True:
        thread_lock.acquire()
        if ISIS_QUEUE.empty():
            thread_lock.release()
            time.sleep(0.0001)
            continue
        msg = ISIS_QUEUE.get()
        if len(msg) < 40:
            print("isis_recv: " + msg)
        msg_fields = msg.split(',')
        send_ip = msg_fields[1]
        resp_ip = msg_fields[3]
        resp_prio = float(msg_fields[4])
        msg_key = ','.join(msg_fields[0:3])

        if send_ip == resp_ip and send_ip != SELF_IP:
            msg_fields[3] = str(SELF_IP)
            msg_fields[4] = str(SELF_PRIORITY)
            SELF_PRIORITY += 1
            msg = ','.join(msg_fields)
            if len(msg) < 40:
                print("isis_recv: ", msg)
            RECV_QUEUE.put(msg)

        if msg_key in ISIS_RESP_DICT:
            old = ISIS_RESP_DICT[msg_key]
            new_prio = max([resp_prio, old[0]])
            new_count = old[1]+1
            new_deliverable = True if new_count == (
                len(CONNECTION_DICT)+1) else False
            ISIS_RESP_DICT[msg_key] = (new_prio, new_count, new_deliverable)
        else:
            ISIS_RESP_DICT[msg_key] = (resp_prio, 1, False)
        thread_lock.release()


def r_recv():
    """
    Thread function for reliable-receive.

    """
    global RECV_QUEUE
    global ISIS_QUEUE
    global SEEN_MSGS_SET
    global SELF_IP
    global SELF_PRIORITY
    global SEEN_QUEUE

    while True:
        thread_lock.acquire()
        if RECV_QUEUE.empty():
            thread_lock.release()
            time.sleep(0.0001)
            continue
        msg = RECV_QUEUE.get()

        msg_fields = msg.split(',')
        send_ip = msg_fields[1]

        if msg not in SEEN_MSGS_SET:
            SEEN_MSGS_SET.add(msg)
            SEEN_QUEUE.put(msg)
            ISIS_QUEUE.put(msg)
            thread_lock.release()
            if send_ip != SELF_IP:
                r_multicast(msg)
        else:
            thread_lock.release()


def r_multicast(msg):
    """
    Helper function for reliable multicast.

    ...

    Parameters
    ----------
    msg : string
        Message to be multicasted.
        msg format : <CONTENT>,<SEND_IP>,<SEND_PRIORITY>,<RESP_IP>,<RESP_PRIORITY>
    """
    global CONNECTION_DICT
    global RECV_QUEUE

    thread_lock.acquire()
    if len(msg) < 40:
        print("r_multicast: ", msg)
    RECV_QUEUE.put(msg)
    msg = struct.pack('>I', len(msg)) + msg.encode()
    for _, recv_socket in CONNECTION_DICT.items():
        try:
            recv_socket.sendall(msg)
        except:
            print("Could not send message")
    thread_lock.release()


def log_delay():
    """
        Thread function to log the delay time of messages propagating to all nodes.

    """
    global MSG_TIME_DICT

    while True:
        thread_lock.acquire()
        keys = []
        with open(str(SELF_NODE) + "_delay.csv", "a") as f:
            for key, val in MSG_TIME_DICT.items():
                if (val < 15):
                    f.write(str(val)+',')
                    keys.append(key)
            f.write('\n')

        for key in keys:
            del MSG_TIME_DICT[key]

        thread_lock.release()
        time.sleep(1)

def log_bandwidth():
    """
        Thread function to log the bandwidth of messages of the node.

    """
    global BW_QUEUE

    while True:
        thread_lock.acquire()

        with open(str(SELF_NODE) + "_BW.csv", "a") as f:
            bw_tot = 0
            while not BW_QUEUE.empty():
                bw_tot += BW_QUEUE.get()
            f.write(str(bw_tot)+',')
            
        thread_lock.release()
        time.sleep(1)


def main(argv):
    if len(argv) != 3:
        print(
            "usage: python3 mp1_node.py [node_id] [port_number] [config_file]")
        return

    global OTHER_NODE_LIST
    global SELF_PORT
    global SELF_NODE

    SELF_NODE = argv[0]
    SELF_PORT = int(argv[1])
    config_file = argv[2]

    with open(config_file) as f:
        contents = f.readlines()
        for i in range(1, len(contents)):
            _, host, port = contents[i].split()
            OTHER_NODE_LIST.append((socket.gethostbyname(host), int(port)))

    global sock
    sock = socket.socket()
    sock.bind(("", SELF_PORT))
    sock.listen(8)

    accept_t = Thread(target=accept_conn)
    accept_t.start()

    print("Connecting to other nodes ...")
    connect_t = Thread(target=connect_other)
    connect_t.start()
    connect_t.join()
    print("Connection completed.")

    r_recv_t = Thread(target=r_recv)
    r_recv_t.start()

    read_stdin_t = Thread(target=read_stdin)
    read_stdin_t.start()

    isis_recv_t = Thread(target=isis_recv)
    isis_recv_t.start()

    isis_send_t = Thread(target=isis_send)
    isis_send_t.start()

    transactions_t = Thread(target=transactions)
    transactions_t.start()

    clear_seen_msg_t = Thread(target=clear_seen_msg)
    clear_seen_msg_t.start()

    log_delay_t = Thread(target=log_delay)
    log_delay_t.start()

    log_bw_t = Thread(target=log_bandwidth)
    log_bw_t.start()

# consulted with Lishen
if __name__ == "__main__":
    main(sys.argv[1:])
